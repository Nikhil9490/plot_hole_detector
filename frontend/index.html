<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AI Plot Hole Detector</title>
    <style>
      body {
        font-family: system-ui, Arial;
        margin: 20px;
        max-width: 1000px;
      }

      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      input[type="text"] {
        width: 240px;
        padding: 10px;
        font-size: 14px;
      }

      textarea {
        width: 100%;
        height: 260px;
        padding: 10px;
        box-sizing: border-box;
        font-size: 14px;
        line-height: 1.35;
      }

      button {
        padding: 10px 14px;
        cursor: pointer;
      }

      .status {
        margin: 10px 0;
        font-size: 13px;
      }

      .card {
        border: 1px solid #ddd;
        border-radius: 10px;
        padding: 12px;
        margin-top: 10px;
      }

      .badge {
        display: inline-block;
        border: 1px solid #aaa;
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 12px;
        margin-right: 6px;
      }

      ul {
        margin: 8px 0 0 18px;
      }

      .muted {
        color: #666;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border: 1px solid #ddd;
        border-radius: 10px;
      }

      .small {
        font-size: 12px;
      }
    </style>
  </head>

  <body>
    <h1>AI Plot Hole Detector</h1>
    <p class="muted">
      Live Mode auto-analyzes after you stop typing. (Debounced, so it won’t spam calls.)
      Tip: Put a blank line between paragraphs for best “Analyze Paragraph” results.
    </p>

    <div class="row">
      <input
        id="docId"
        type="text"
        value="novel-ch1"
        placeholder="docId (e.g., novel-ch1)"
      />

      <button id="clipboardBtn">Analyze Clipboard</button>
      <button id="paragraphBtn">Analyze Paragraph</button>
      <button id="fullBtn">Analyze Full Text</button>

      <label class="toggle">
        <input id="liveToggle" type="checkbox" />
        <span>Live Mode</span>
        <span class="muted small" id="liveHint">(off)</span>
      </label>
    </div>

    <div style="margin-top: 10px;">
      <textarea id="text" placeholder="Paste your scene here..."></textarea>
    </div>

    <div class="status" id="status"></div>

    <h2>Issues</h2>
    <div id="issues"></div>

    <script>
      // Backend API (FastAPI)
      const API = "http://127.0.0.1:8000";

      // UI elements
      const docIdEl = document.getElementById("docId");
      const textEl = document.getElementById("text");
      const statusEl = document.getElementById("status");
      const issuesEl = document.getElementById("issues");

      const clipboardBtn = document.getElementById("clipboardBtn");
      const paragraphBtn = document.getElementById("paragraphBtn");
      const fullBtn = document.getElementById("fullBtn");

      const liveToggle = document.getElementById("liveToggle");
      const liveHint = document.getElementById("liveHint");

      // Live mode settings
      const LIVE_DEBOUNCE_MS = 1200;
      const MIN_CHARS_TO_LIVE_ANALYZE = 60;

      let liveTimer = null;
      let inFlight = false;
      let lastSentTextHash = "";

      function setStatus(msg) {
        statusEl.textContent = msg || "";
      }

      function setButtonsDisabled(disabled) {
        clipboardBtn.disabled = disabled;
        paragraphBtn.disabled = disabled;
        fullBtn.disabled = disabled;
      }

      function render(issues) {
        issuesEl.innerHTML = "";

        if (!issues || issues.length === 0) {
          issuesEl.innerHTML = `<div class="card">No issues found.</div>`;
          return;
        }

        for (const it of issues) {
          const div = document.createElement("div");
          div.className = "card";

          const header = document.createElement("div");
          header.innerHTML = `
            <span class="badge">${escapeHtml(it.type || "Other")}</span>
            <span class="badge">${escapeHtml(it.severity || "low")}</span>
          `;
          div.appendChild(header);

          const msg = document.createElement("div");
          msg.style.marginTop = "8px";
          msg.textContent = it.message || "";
          div.appendChild(msg);

          if (it.evidence && it.evidence.length) {
            const ul = document.createElement("ul");
            for (const ev of it.evidence) {
              const li = document.createElement("li");
              li.textContent = ev;
              ul.appendChild(li);
            }
            div.appendChild(ul);
          }

          issuesEl.appendChild(div);
        }
      }

      // Simple safe HTML escape for badges
      function escapeHtml(s) {
        return String(s)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function getDocId() {
        const v = docIdEl.value.trim();
        return v ? v : "default";
      }

      // Hash for "same text" skipping in live mode
      function tinyHash(s) {
        let h = 0;
        for (let i = 0; i < s.length; i++) {
          h = (h * 31 + s.charCodeAt(i)) >>> 0;
        }
        return String(h);
      }

      async function callAnalyze(text, modeLabel) {
        const docId = getDocId();
        const payload = { docId, text };

        setButtonsDisabled(true);
        inFlight = true;

        try {
          const res = await fetch(`${API}/analyze`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          if (!res.ok) {
            const t = await res.text();
            throw new Error(`API ${res.status}: ${t}`);
          }

          const data = await res.json();
          render(data.issues);
          setStatus(`Done (${modeLabel}). Found ${data.issues.length} issue(s).`);
        } catch (e) {
          setStatus("Error: " + e.message);
        } finally {
          inFlight = false;
          setButtonsDisabled(false);
        }
      }

      // ---------- Button actions ----------
      async function analyzeFullText() {
        const text = textEl.value.trim();
        if (!text) {
          setStatus("Paste some text first.");
          return;
        }

        setStatus("Analyzing full text...");
        await callAnalyze(text, "full text");
      }

      async function analyzeClipboard() {
        try {
          setStatus("Reading clipboard...");
          const clipText = await navigator.clipboard.readText();

          if (!clipText.trim()) {
            setStatus("Clipboard is empty. Copy something first.");
            return;
          }

          textEl.value = clipText;

          setStatus("Analyzing clipboard...");
          await callAnalyze(clipText.trim(), "clipboard");
        } catch (e) {
          setStatus("Clipboard error: " + e.message);
        }
      }

      function extractParagraphAtCursor(fullText, cursorPos) {
        // Paragraph = block separated by ONE OR MORE blank lines.
        // More robust than the previous regex approach.

        // Normalize Windows line endings
        const text = fullText.replaceAll("\r\n", "\n");

        // Clamp cursor
        const pos = Math.max(0, Math.min(cursorPos, text.length));

        // If there's no blank line at all, treat whole text as one paragraph.
        const hasBlankLine = /\n\s*\n/.test(text);
        if (!hasBlankLine) {
          return text.trim();
        }

        // Find start: last blank-line boundary before cursor
        const before = text.slice(0, pos);
        const startBoundary = before.lastIndexOf("\n\n");
        const start = startBoundary === -1 ? 0 : startBoundary + 2;

        // Find end: next blank-line boundary after cursor
        const after = text.slice(pos);
        const nextBoundaryInAfter = after.search(/\n\s*\n/);
        const end =
          nextBoundaryInAfter === -1 ? text.length : pos + nextBoundaryInAfter;

        const para = text.slice(start, end).trim();
        return para;
      }

      async function analyzeParagraph() {
        const fullText = textEl.value;
        if (!fullText.trim()) {
          setStatus("Paste some text first.");
          return;
        }

        const cursor = typeof textEl.selectionStart === "number" ? textEl.selectionStart : 0;
        const para = extractParagraphAtCursor(fullText, cursor);

        if (!para) {
          setStatus("No paragraph found. Add a blank line between paragraphs.");
          return;
        }

        setStatus("Analyzing paragraph...");
        await callAnalyze(para, "paragraph");
      }

      // ---------- Live mode ----------
      function scheduleLiveAnalyze() {
        if (!liveToggle.checked) return;

        const text = textEl.value.trim();

        if (text.length < MIN_CHARS_TO_LIVE_ANALYZE) {
          setStatus(
            `Live Mode: waiting (need ${MIN_CHARS_TO_LIVE_ANALYZE}+ chars).`
          );
          return;
        }

        if (inFlight) {
          setStatus("Live Mode: waiting (request in progress)...");
          return;
        }

        const h = tinyHash(text);
        if (h === lastSentTextHash) {
          setStatus("Live Mode: no changes since last analyze.");
          return;
        }

        if (liveTimer) clearTimeout(liveTimer);

        setStatus(
          `Live Mode: analyzing in ${Math.round(LIVE_DEBOUNCE_MS / 100) / 10}s...`
        );

        liveTimer = setTimeout(async () => {
          const nowText = textEl.value.trim();
          if (nowText.length < MIN_CHARS_TO_LIVE_ANALYZE) return;

          const nowHash = tinyHash(nowText);
          if (nowHash === lastSentTextHash) return;

          lastSentTextHash = nowHash;
          setStatus("Live Mode: analyzing...");
          await callAnalyze(nowText, "live");
        }, LIVE_DEBOUNCE_MS);
      }

      // Events
      fullBtn.addEventListener("click", analyzeFullText);
      clipboardBtn.addEventListener("click", analyzeClipboard);
      paragraphBtn.addEventListener("click", analyzeParagraph);

      liveToggle.addEventListener("change", () => {
        if (liveToggle.checked) {
          liveHint.textContent = "(on)";
          scheduleLiveAnalyze();
        } else {
          liveHint.textContent = "(off)";
          if (liveTimer) clearTimeout(liveTimer);
          setStatus("");
        }
      });

      // Trigger live mode on typing / paste
      textEl.addEventListener("input", scheduleLiveAnalyze);
      textEl.addEventListener("paste", () => setTimeout(scheduleLiveAnalyze, 0));
    </script>
  </body>
</html>
