<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AI Plot Hole Detector</title>
    <style>
      body {
        font-family: system-ui, Arial;
        margin: 20px;
        max-width: 1000px;
      }

      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      input[type="text"] {
        width: 240px;
        padding: 10px;
        font-size: 14px;
      }

      textarea {
        width: 100%;
        height: 260px;
        padding: 10px;
        box-sizing: border-box;
        font-size: 14px;
        line-height: 1.35;
        white-space: pre-wrap;
      }

      button {
        padding: 10px 14px;
        cursor: pointer;
      }

      .status {
        margin: 10px 0;
        font-size: 13px;
      }

      .card {
        border: 1px solid #ddd;
        border-radius: 10px;
        padding: 12px;
        margin-top: 10px;
      }

      .badge {
        display: inline-block;
        border: 1px solid #aaa;
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 12px;
        margin-right: 6px;
      }

      ul {
        margin: 8px 0 0 18px;
      }

      .muted {
        color: #666;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border: 1px solid #ddd;
        border-radius: 10px;
      }

      .small {
        font-size: 12px;
      }
    </style>
  </head>

  <body>
    <h1>AI Plot Hole Detector</h1>
    <p class="muted">
      Live Mode auto-analyzes after you stop typing. Tip: italic text pasted from Word becomes [[THOUGHT]] blocks.
    </p>

    <div class="row">
      <input id="docId" type="text" value="novel-ch1" placeholder="docId (e.g., novel-ch1)" />

      <button id="clipboardBtn">Analyze Clipboard</button>
      <button id="paragraphBtn">Analyze Paragraph</button>
      <button id="fullBtn">Analyze Full Text</button>

      <label class="toggle">
        <input id="liveToggle" type="checkbox" />
        <span>Live Mode</span>
        <span class="muted small" id="liveHint">(off)</span>
      </label>
    </div>

    <div style="margin-top: 10px;">
      <textarea id="text" placeholder="Paste your scene here..."></textarea>
    </div>

    <div class="status" id="status"></div>

    <h2>Issues</h2>
    <div id="issues"></div>

    <script>
      const API = "http://127.0.0.1:8000";

      const docIdEl = document.getElementById("docId");
      const textEl = document.getElementById("text");
      const statusEl = document.getElementById("status");
      const issuesEl = document.getElementById("issues");

      const clipboardBtn = document.getElementById("clipboardBtn");
      const paragraphBtn = document.getElementById("paragraphBtn");
      const fullBtn = document.getElementById("fullBtn");

      const liveToggle = document.getElementById("liveToggle");
      const liveHint = document.getElementById("liveHint");

      const LIVE_DEBOUNCE_MS = 1200;
      const MIN_CHARS_TO_LIVE_ANALYZE = 60;

      let liveTimer = null;
      let inFlight = false;
      let lastSentTextHash = "";

      function setStatus(msg) {
        statusEl.textContent = msg || "";
      }

      function setButtonsDisabled(disabled) {
        clipboardBtn.disabled = disabled;
        paragraphBtn.disabled = disabled;
        fullBtn.disabled = disabled;
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function render(issues) {
        issuesEl.innerHTML = "";

        if (!issues || issues.length === 0) {
          issuesEl.innerHTML = `<div class="card">No issues found.</div>`;
          return;
        }

        for (const it of issues) {
          const div = document.createElement("div");
          div.className = "card";

          const header = document.createElement("div");
          header.innerHTML = `
            <span class="badge">${escapeHtml(it.type || "other")}</span>
            <span class="badge">${escapeHtml(it.severity || "low")}</span>
          `;
          div.appendChild(header);

          const msg = document.createElement("div");
          msg.style.marginTop = "8px";
          msg.textContent = it.message || "";
          div.appendChild(msg);

          if (it.evidence && it.evidence.length) {
            const ul = document.createElement("ul");
            for (const ev of it.evidence) {
              const li = document.createElement("li");
              li.textContent = ev;
              ul.appendChild(li);
            }
            div.appendChild(ul);
          }

          issuesEl.appendChild(div);
        }
      }

      function getDocId() {
        const v = docIdEl.value.trim();
        return v ? v : "default";
      }

      function tinyHash(s) {
        let h = 0;
        for (let i = 0; i < s.length; i++) {
          h = (h * 31 + s.charCodeAt(i)) >>> 0;
        }
        return String(h);
      }

      async function callAnalyze(text, modeLabel) {
        const docId = getDocId();
        const payload = { docId, text };

        setButtonsDisabled(true);
        inFlight = true;

        try {
          const res = await fetch(`${API}/analyze`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (!res.ok) {
            const t = await res.text();
            throw new Error(`API ${res.status}: ${t}`);
          }

          const data = await res.json();
          render(data.issues);

          setStatus(`Done (${modeLabel}). Found ${data.issues.length} issue(s).`);
        } catch (e) {
          setStatus("Error: " + e.message);
        } finally {
          inFlight = false;
          setButtonsDisabled(false);
        }
      }

      async function analyzeFullText() {
        const text = textEl.value.trim();
        if (!text) return setStatus("Paste some text first.");
        setStatus("Analyzing full text...");
        await callAnalyze(text, "full text");
      }

      async function analyzeClipboard() {
        try {
          setStatus("Reading clipboard...");
          const clipText = await navigator.clipboard.readText();
          if (!clipText.trim()) return setStatus("Clipboard is empty. Copy something first.");
          textEl.value = clipText;
          setStatus("Analyzing clipboard...");
          await callAnalyze(clipText.trim(), "clipboard");
        } catch (e) {
          setStatus("Clipboard error: " + e.message);
        }
      }

      function extractParagraphAtCursor(fullText, cursorPos) {
        const before = fullText.slice(0, cursorPos);
        const after = fullText.slice(cursorPos);

        const startMatch = before.match(/(\n\s*\n)[\s\S]*$/);
        const startIndex = startMatch ? startMatch.index + startMatch[1].length : 0;

        const endMatch = after.match(/\n\s*\n/);
        const endIndex = endMatch ? cursorPos + endMatch.index : fullText.length;

        return fullText.slice(startIndex, endIndex).trim();
      }

      async function analyzeParagraph() {
        const fullText = textEl.value;
        if (!fullText.trim()) return setStatus("Paste some text first.");

        const cursor = textEl.selectionStart ?? 0;
        const para = extractParagraphAtCursor(fullText, cursor);

        if (!para) return setStatus("No paragraph found. Add a blank line between paragraphs.");

        setStatus("Analyzing paragraph...");
        await callAnalyze(para, "paragraph");
      }

      function scheduleLiveAnalyze() {
        if (!liveToggle.checked) return;

        const text = textEl.value.trim();

        if (text.length < MIN_CHARS_TO_LIVE_ANALYZE) {
          setStatus(`Live Mode: waiting (need ${MIN_CHARS_TO_LIVE_ANALYZE}+ chars).`);
          return;
        }

        if (inFlight) {
          setStatus("Live Mode: waiting (request in progress)...");
          return;
        }

        const h = tinyHash(text);
        if (h === lastSentTextHash) {
          setStatus("Live Mode: no changes since last analyze.");
          return;
        }

        if (liveTimer) clearTimeout(liveTimer);

        setStatus(`Live Mode: analyzing in ${Math.round(LIVE_DEBOUNCE_MS / 100) / 10}s...`);
        liveTimer = setTimeout(async () => {
          const nowText = textEl.value.trim();
          if (nowText.length < MIN_CHARS_TO_LIVE_ANALYZE) return;

          const nowHash = tinyHash(nowText);
          if (nowHash === lastSentTextHash) return;

          lastSentTextHash = nowHash;
          setStatus("Live Mode: analyzing...");
          await callAnalyze(nowText, "live");
        }, LIVE_DEBOUNCE_MS);
      }

      // -----------------------------
      // NEW: Preserve italics from Word paste
      // Converts <i>/<em> to [[THOUGHT]]...[[/THOUGHT]]
      // -----------------------------
      function htmlToTextWithThoughtMarkers(html) {
        const doc = new DOMParser().parseFromString(html, "text/html");

        function walk(node, inThought) {
          let out = "";

          if (node.nodeType === Node.TEXT_NODE) {
            return node.nodeValue || "";
          }

          if (node.nodeType !== Node.ELEMENT_NODE) return "";

          const tag = node.tagName.toLowerCase();

          // Word sometimes uses <i>, <em>, or spans with font-style: italic
          const isItalicTag = (tag === "i" || tag === "em");
          const isItalicStyle =
            tag === "span" &&
            node.getAttribute("style") &&
            node.getAttribute("style").toLowerCase().includes("font-style: italic");

          const nowThought = inThought || isItalicTag || isItalicStyle;

          if (!inThought && nowThought) out += "[[THOUGHT]]";
          if (inThought && !nowThought) out += "[[/THOUGHT]]";

          if (tag === "br") return "\n";
          if (tag === "p") {
            // paragraph boundary
            for (const child of node.childNodes) out += walk(child, nowThought);
            return out + "\n\n";
          }

          for (const child of node.childNodes) out += walk(child, nowThought);

          // close thought when leaving an italic block
          if (!inThought && nowThought) out += "[[/THOUGHT]]";

          return out;
        }

        let text = "";
        for (const child of doc.body.childNodes) {
          text += walk(child, false);
        }

        // Normalize weird spacing/newlines
        text = text.replace(/\r/g, "");
        text = text.replace(/\n{3,}/g, "\n\n");
        return text.trim();
      }

      function insertAtCursor(textarea, insertText) {
        const start = textarea.selectionStart ?? textarea.value.length;
        const end = textarea.selectionEnd ?? textarea.value.length;
        const before = textarea.value.slice(0, start);
        const after = textarea.value.slice(end);

        textarea.value = before + insertText + after;

        const newPos = (before + insertText).length;
        textarea.setSelectionRange(newPos, newPos);
      }

      textEl.addEventListener("paste", (e) => {
        // Try to grab HTML first (to preserve italics)
        const html = e.clipboardData?.getData("text/html");
        if (html && html.trim()) {
          e.preventDefault();
          const converted = htmlToTextWithThoughtMarkers(html);
          insertAtCursor(textEl, converted);
          // trigger live analysis (if on)
          setTimeout(scheduleLiveAnalyze, 0);
          return;
        }
        // otherwise normal paste will happen (plain text)
        setTimeout(scheduleLiveAnalyze, 0);
      });

      // -----------------------------
      // Events
      // -----------------------------
      fullBtn.addEventListener("click", analyzeFullText);
      clipboardBtn.addEventListener("click", analyzeClipboard);
      paragraphBtn.addEventListener("click", analyzeParagraph);

      liveToggle.addEventListener("change", () => {
        if (liveToggle.checked) {
          liveHint.textContent = "(on)";
          scheduleLiveAnalyze();
        } else {
          liveHint.textContent = "(off)";
          if (liveTimer) clearTimeout(liveTimer);
          setStatus("");
        }
      });

      textEl.addEventListener("input", scheduleLiveAnalyze);
    </script>
  </body>
</html>
