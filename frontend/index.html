<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AI Plot Hole Detector</title>
    <style>
      body {
        font-family: system-ui, Arial;
        margin: 20px;
        max-width: 1000px;
      }

      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      input[type="text"] {
        width: 240px;
        padding: 10px;
        font-size: 14px;
      }

      textarea {
        width: 100%;
        height: 260px;
        padding: 10px;
        box-sizing: border-box;
        font-size: 14px;
        line-height: 1.35;
      }

      button {
        padding: 10px 14px;
        cursor: pointer;
      }

      .status {
        margin: 10px 0;
        font-size: 13px;
      }

      .card {
        border: 1px solid #ddd;
        border-radius: 10px;
        padding: 12px;
        margin-top: 10px;
      }

      .badge {
        display: inline-block;
        border: 1px solid #aaa;
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 12px;
        margin-right: 6px;
      }

      ul {
        margin: 8px 0 0 18px;
      }

      .muted {
        color: #666;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border: 1px solid #ddd;
        border-radius: 10px;
      }

      .small {
        font-size: 12px;
      }
    </style>
  </head>

  <body>
    <h1>AI Plot Hole Detector</h1>
    <p class="muted">
      Live Mode auto-analyzes after you stop typing. Tip: Word italics pasted via “Analyze Clipboard”
      become <code>[[THOUGHT]]</code> blocks.
    </p>

    <div class="row">
      <input id="docId" type="text" value="novel-ch1" placeholder="docId (e.g., novel-ch1)" />

      <button id="clipboardBtn">Analyze Clipboard</button>
      <button id="paragraphBtn">Analyze Paragraph</button>
      <button id="fullBtn">Analyze Full Text</button>

      <label class="toggle">
        <input id="liveToggle" type="checkbox" />
        <span>Live Mode</span>
        <span class="muted small" id="liveHint">(off)</span>
      </label>
    </div>

    <div style="margin-top: 10px;">
      <textarea id="text" placeholder="Paste your scene here..."></textarea>
    </div>

    <div class="status" id="status"></div>

    <h2>Issues</h2>
    <div id="issues"></div>

    <script>
      // Backend API (FastAPI)
      const API = "http://127.0.0.1:8000";

      // UI elements
      const docIdEl = document.getElementById("docId");
      const textEl = document.getElementById("text");
      const statusEl = document.getElementById("status");
      const issuesEl = document.getElementById("issues");

      const clipboardBtn = document.getElementById("clipboardBtn");
      const paragraphBtn = document.getElementById("paragraphBtn");
      const fullBtn = document.getElementById("fullBtn");

      const liveToggle = document.getElementById("liveToggle");
      const liveHint = document.getElementById("liveHint");

      // Live mode settings
      const LIVE_DEBOUNCE_MS = 1200;
      const MIN_CHARS_TO_LIVE_ANALYZE = 80;

      let liveTimer = null;
      let inFlight = false;
      let lastSentTextHash = "";

      function setStatus(msg) {
        statusEl.textContent = msg || "";
      }

      function setButtonsDisabled(disabled) {
        clipboardBtn.disabled = disabled;
        paragraphBtn.disabled = disabled;
        fullBtn.disabled = disabled;
      }

      function render(issues) {
        issuesEl.innerHTML = "";

        if (!issues || issues.length === 0) {
          issuesEl.innerHTML = `<div class="card">No issues found.</div>`;
          return;
        }

        for (const it of issues) {
          const div = document.createElement("div");
          div.className = "card";

          const header = document.createElement("div");
          header.innerHTML = `
            <span class="badge">${escapeHtml(it.type || "logic")}</span>
            <span class="badge">${escapeHtml(it.severity || "low")}</span>
          `;
          div.appendChild(header);

          const msg = document.createElement("div");
          msg.style.marginTop = "8px";
          msg.textContent = it.message || "";
          div.appendChild(msg);

          if (it.evidence && it.evidence.length) {
            const ul = document.createElement("ul");
            for (const ev of it.evidence) {
              const li = document.createElement("li");
              li.textContent = ev;
              ul.appendChild(li);
            }
            div.appendChild(ul);
          }

          issuesEl.appendChild(div);
        }
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function getDocId() {
        const v = docIdEl.value.trim();
        return v ? v : "default";
      }

      function tinyHash(s) {
        let h = 0;
        for (let i = 0; i < s.length; i++) {
          h = (h * 31 + s.charCodeAt(i)) >>> 0;
        }
        return String(h);
      }

      async function callAnalyze(text, modeLabel) {
        const docId = getDocId();

        setButtonsDisabled(true);
        inFlight = true;

        try {
          const res = await fetch(`${API}/analyze`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ docId, text })
          });

          if (!res.ok) {
            const t = await res.text();
            throw new Error(`API ${res.status}: ${t}`);
          }

          const data = await res.json();
          render(data.issues);
          setStatus(`Done (${modeLabel}). Found ${data.issues.length} issue(s).`);
        } catch (e) {
          setStatus("Error: " + e.message);
        } finally {
          inFlight = false;
          setButtonsDisabled(false);
        }
      }

      // ----------------------------
      // Actions
      // ----------------------------
      async function analyzeFullText() {
        const text = textEl.value.trim();
        if (!text) {
          setStatus("Paste some text first.");
          return;
        }
        setStatus("Analyzing full text...");
        await callAnalyze(text, "full text");
      }

      // Converts HTML clipboard to text, turning italics into [[THOUGHT]] blocks
      function htmlToThoughtTaggedText(html) {
        const div = document.createElement("div");
        div.innerHTML = html;

        // Convert <i>/<em> to explicit thought tags
        div.querySelectorAll("i, em").forEach((el) => {
          const t = el.textContent || "";
          el.textContent = `[[THOUGHT]] ${t} [[/THOUGHT]]`;
        });

        // Convert <br> and <p> into newlines naturally via innerText
        return div.innerText;
      }

      async function analyzeClipboard() {
        try {
          setStatus("Reading clipboard...");

          // Best case: we can read HTML (Word formatting survives here)
          if (navigator.clipboard && navigator.clipboard.read) {
            const items = await navigator.clipboard.read();

            for (const item of items) {
              if (item.types.includes("text/html")) {
                const blob = await item.getType("text/html");
                const html = await blob.text();

                const tagged = htmlToThoughtTaggedText(html).trim();
                if (!tagged) {
                  setStatus("Clipboard HTML was empty.");
                  return;
                }

                textEl.value = tagged;
                setStatus("Analyzing clipboard (formatted)...");
                await callAnalyze(tagged, "clipboard formatted");
                return;
              }
            }
          }

          // Fallback: plain text
          const clipText = await navigator.clipboard.readText();
          if (!clipText.trim()) {
            setStatus("Clipboard is empty. Copy something first.");
            return;
          }

          textEl.value = clipText;
          setStatus("Analyzing clipboard...");
          await callAnalyze(clipText.trim(), "clipboard");
        } catch (e) {
          setStatus("Clipboard error: " + e.message);
        }
      }

      // Paragraph = block separated by ONE OR MORE blank lines
      function extractParagraphAtCursor(fullText, cursorPos) {
        // Normalize Windows newlines
        const t = fullText.replaceAll("\r\n", "\n");

        // Find nearest blank-line boundary before cursor
        const before = t.slice(0, cursorPos);
        const after = t.slice(cursorPos);

        const startBoundary = before.lastIndexOf("\n\n");
        const startIndex = startBoundary === -1 ? 0 : startBoundary + 2;

        const endBoundary = after.indexOf("\n\n");
        const endIndex = endBoundary === -1 ? t.length : cursorPos + endBoundary;

        return t.slice(startIndex, endIndex).trim();
      }

      async function analyzeParagraph() {
        const fullText = textEl.value;
        if (!fullText.trim()) {
          setStatus("Paste some text first.");
          return;
        }

        const cursor = textEl.selectionStart ?? 0;
        const para = extractParagraphAtCursor(fullText, cursor);

        if (!para) {
          setStatus("No paragraph found. Add a blank line between paragraphs.");
          return;
        }

        setStatus("Analyzing paragraph...");
        await callAnalyze(para, "paragraph");
      }

      // ----------------------------
      // Live mode
      // ----------------------------
      function scheduleLiveAnalyze() {
        if (!liveToggle.checked) return;

        const text = textEl.value.trim();

        if (text.length < MIN_CHARS_TO_LIVE_ANALYZE) {
          setStatus(`Live Mode: waiting (need ${MIN_CHARS_TO_LIVE_ANALYZE}+ chars).`);
          return;
        }

        if (inFlight) {
          setStatus("Live Mode: waiting (request in progress)...");
          return;
        }

        const h = tinyHash(text);
        if (h === lastSentTextHash) {
          setStatus("Live Mode: no changes since last analyze.");
          return;
        }

        if (liveTimer) clearTimeout(liveTimer);

        setStatus(`Live Mode: analyzing in ${Math.round(LIVE_DEBOUNCE_MS / 100) / 10}s...`);
        liveTimer = setTimeout(async () => {
          const nowText = textEl.value.trim();
          if (nowText.length < MIN_CHARS_TO_LIVE_ANALYZE) return;

          const nowHash = tinyHash(nowText);
          if (nowHash === lastSentTextHash) return;

          lastSentTextHash = nowHash;
          setStatus("Live Mode: analyzing...");
          await callAnalyze(nowText, "live");
        }, LIVE_DEBOUNCE_MS);
      }

      // Events
      fullBtn.addEventListener("click", analyzeFullText);
      clipboardBtn.addEventListener("click", analyzeClipboard);
      paragraphBtn.addEventListener("click", analyzeParagraph);

      liveToggle.addEventListener("change", () => {
        if (liveToggle.checked) {
          liveHint.textContent = "(on)";
          scheduleLiveAnalyze();
        } else {
          liveHint.textContent = "(off)";
          if (liveTimer) clearTimeout(liveTimer);
          setStatus("");
        }
      });

      textEl.addEventListener("input", scheduleLiveAnalyze);
      textEl.addEventListener("paste", () => setTimeout(scheduleLiveAnalyze, 0));
    </script>
  </body>
</html>
